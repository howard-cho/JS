JavaScript has 6 basis data types. Called primitives.

1. String
2. Number
3. Boolean
4. Null
5. Undefined
6. Symbol

--- String - represents text data in JavaScript

`JavaScript is easier than I thought!`

Black text in Chrome console is a string

console.log(`JavaScript is easier than I thought!`)


Strings with apostrophes (') can be created with single quotation marks if you add a backslash \ before the apostrophe.

'It\'s my birthday today!'

They can also be created with backticks (``).
Strings created with backticks are called template strings.

`It's my birthday today!`


Strings can be added together with the + operator.
Called concatenation.

console.log('Super' + 'man') // Superman
console.log('1' + '1') // 11


--- Number - represents numeric data

Blue text in Chrome console is a number

console.log(34123) // 34123

Numbers in JS behave like numbers in math

console.log(1 + 1) // 2
console.log(20 + 2) // 22
console.log(22 - 2) // 20
console.log(22 * 2) // 44
console.log(22 / 2) // 11

To find the remainder of a number: %

// Find the remainder of 22 / 5
console.log(22 % 5) // 2 


--- Boolean - true or false

Blue text in Chrome console


--- Null and undefined

--- Symbol - new primitive in ES6



--- VARIABLES

Declare variables with the following syntax

const variableName = 'value'

Variable naming rules:
1. Must be one word
2. Must consist only of letters, numbers or underscores (0-9, a-z, A-Z, _)
3. It cannot begin with a number
4. It cannot be a reserved keyword

Should use camelCase


Variable values can be primitive data types or objects (like arrays and functions)

= means assignment in JS
You set (or assign) the value on the right hand side of the = to the left hand side of the =

const initialApples = 4



Equations that need to be evaluated are called expressions in JS.

const initialApples = 4
const applesToBuy = 27

// initialApples + applesToBuy is an expression

const totalApples = initialApples + applesToBuy


Keyword to declare variables:
const | let | var

const and let are keywords made available in ES6

const - cannot reassign variable with a new value

let - you can reassign with a new value



Use const over let. No more var




--- FUNCTIONS

A function is a block of code that executes tasks in a specific order

function functionName (parameters) {
	// Do stuff here
}

Function naming:
1. Must be one word
2. Must consist only of letters, numbers or underscores (0-9, a-z, A-Z, _)
3. Cannot begin with a number
4. Cannot use any reserved keywords





To use (or invoke, or call, or execute) a function:

functionName()

// Declaring a function
function sayHello() {
	console.log('Hello world!')
}


// Using a function
sayHello()


Indent with 2 spaces or a tab key.




Parameters are optional, comma-separated list of variables you wish to declare for your function. They can be assigned values when you use the function.

You can have any number of parameters.

function functionName(param1, param2, param3) {
	// Do stuff here
}


To assign values to parameters, you pass in arguments.
Arguments are comma-separated values you use in the function call.

The first argument gets assigned to the first parameter, the second argument to the second parameter, and so on.

functionName('arg1', 'arg2')

function sayName(firstName, lastName) {
	console.log('firstName is ' + firstName)
	console.log('lastName is ' + lastName)
}

sayName('Howard', 'Cho')
// firstName is Howard
// lastName is Cho


If you declared a parameter, but did not pass an argument to it, your paramter would be undefined.
sayName()
// firstName is undefined
// lastName is undefined



The return statement
When JS sees a return statement, it stops executing the rest of the function and "returns" the value (passes the value back to expression that called the function call).

function get2() {
	return 2
	console.log('blah') // This is not executed
}

If the return value is an expression, JavaScript evaluates the expression before returning the value.

function add2(num) {
	return num + 2
}

const number = add2(8)
console.log(number) // 10


JavaScript can only pass around two types of values. Everything else needs to be evaluated first.
1. Primitives (Strings, numbers, booleans, etc)
2. Objects (functions, arrays, other objects)


A function call is an expression
function add2(num) {
	return num + 2
}

// add2 is a function. It can be passed around
const anotherAdd2 = add2
console.log(anotherAdd2) // function
anotherAdd2(3) // 5

----------------------------------------------

function add2(num) {
	return num + 2
}

// add2(2) is an expression, It needs to be evaluated first.
const sum = add2(2)
console.log(sum) // 4


When functions are declared with a function declaration, they are hoisted to the top of your scope.

You should not rely on hoisting. Declare your functions before you use them.


Declaring a function with a function expression:

// Functions without a name are called 'anonymous functions'
const sayHello = function () {
	console.log('This is declared with a function expression!')
}

*** Functions declared with function expressions are not automatically hoisted to the top of your scope. ***

sayHello() // Error, sayHello is not defined
const sayHello = function() {
	console.log(aFunction)
}



function logger(something) {
	console.log(something)
}

function add(num1, num2) {
	console.log(num1 + num2)
}

function multiply(num1, num2) {
	console.log(num1 * num2)
}



----------------------------------------------------------

Arrow Functions

New way to make anonymous functions in ES6.

Basically remove the function keyword, and add => after parenthesis.

// Normal function (with Function expression)
const normalFunction = function (arg1, arg2) {
	// Do something
}

// Arrow function
const arrowFunction = (arg1, arg2) => {
	// Do something
}

Syntax can change based on two factors
1. The number of arguments required
2. Whether you'd like an implicit return

### If you supply ZERO arguments to your arrow function, you can substitute the parenthesis with an underscore ( _ )

const zeroArgs = () => {/* do something */}
const zeroWithUnderScore = _ => {/* do something */}

### If you supply only one argument, you can remove the parenthesis

const oneArg = arg1 => {/* do something */}
const oneArgWithParenthesis = (arg1) => {/* do something */}

### If you supply two or more arguments, you need to use the basic arrow function syntax

const twoOrMoreArgs = (arg1, arg2) => {/* do something */}



### Arrow functions automatically create a return statement if two conditions are present:
1. You write only one line of code in the function
2. That line of code is not enclosed in curly braces ( {} )

Reduce three lines of code into a single line
// 3 lines of code for a normal function
const sumNormal = function (num1, num2) {
	return num1 + num2
}

// Replaced with one line of code with arrow function
const sumArrow = (num1, num2) => num1 + num2


Arrow function exercises
1. Make a function named ten that takes in zero arguments and return the value 10. Try using both () and _ syntax.

const ten = _ => 10
const ten = () => 10

2. Make a function named logger that takes in one argument. It logs the argument you passed into it. Try it with and without parenthesis ().

const logger = arg1 => console.log(arg1)
const logger = (arg1) => console.log(arg1)


3. Make a function called add that adds two numbers together. Try it with and without implicit returns.

const add = (arg1, arg2) => arg1 + arg2
const add = (arg1, arg2) => {
	return arg1 + arg2
}

4. Make a function called multiply that multiplies two numbers together. Try it with and without implicit returns.

const multiply = (arg1, arg2) => arg1 * arg2
const multiply = (arg1, arg2) => {
	return arg1 * arg2
}

------------------------------------------------------

Intro to Objects

Important because you can only pass two types of data around as variables - primitives and objects.

Object is data that contains key-value pairs.


Key-value pairs within curly braces.
Multiple key-value pairs are separated with commas.

const anObject = {
	key1: 'value1',
	key2: 'value2',
	key3: 'value3'
	// ...
}

Each key gives you a reference to a value.
Dictionary analogy - keys are the words, values are definition of the word.

const dictionary = {
	dream: "a series of thoughts, images, and sensations occurring in a person's mind during sleep",
	happy: "feeling or showing pleasure or contentment"
}


Compare objects in JS to objects in real life.

const macbook = {
	operatingSystem: 'macOS Sierra',
	screenResolution: '2880x1800',
	screenSize: '15.4 inch',
	usbPorts: 2,
	storage: '512gb'
	// ... Other specs
}


Objects can contain any value that is valid in JS.
You can store primitives and other objects.

const anObject = {
	string: 'Yay',
	number: 1,
	boolean: true,
	anotherObject: {},
	afunction: function () {},
	anArray: []
}


Object keys are called Properties

Two methods to get the value of a property.

### Dot notation
Write the name of the object, followed by . followed by the property name

const prop = object.property

const macbookStorage = macbook.storage
console.log(macbookStorage) // 512gb


### Bracket notation
Write the name of the object, followed by a string of the property in square brackets [].

const macbookStorage = macbook['storage']
console.log(macbookStorage) // 512gb


Dot notation is normally used.
Bracket notation is used in special occassions:
1. When your property name is an invalid identifier
2. When you need to get the value of a property through a variable

### Anything that can't be a variable name is an invalid identifier

const firstName = ObjectWithInvalidIdentifier['First Name']


### Getting the value of a property through a variable

const propertyToGet = 'storage'

const macbookStorage = macbook[propertyToGet]
console.log(macbookStorage) // 512gb



### Setting the value of a property
Value of a property can be set using dot or bracket notation

// Dot notation
macbook.storage = '256gb'

// Bracket notation
macbook['usbPorts'] = 2

console.log(macbook)
// {
//   storage: '256gb',
//   usbPorts: 2
// }



### Deleting Properties
Delete key-value pairs from objects with the delete keyword.

delete object.property

delete macbook.storage
console.log(macbook)
// The storage property is already deleted, hence you don't see it anymore when you console.log it
// {
//   usbPorts: 2
// }


### Functions are objects in JavaScript
They can have properties too.

function sayName () {}
sayName.property = 'Hello!'

console.log(sayName.property) // Hello!


### The properties that contain functions as their values are called methods

const anObject = {
	aMethod: function() {
		// Do something in function
	}
}

// playMusic is a method of macbook
const macbook = {
	playMusic: function () {
		/* some code to play music */
	}
}

### To call a method, write parenthesis () after getting the method through the dot or bracket notation

// Calling a method with the dot notation
macbook.playMusic()

// Calling a method with the bracket notation
macbook['playMusic']()


### You can also add arguments to methods

const greeter = {
	sayHello: function (name) {
		console.log('Hello ' + name + '!')
	}
}

greeter.sayHello('Howard') // Hello Howard!

Exercises:

1. Make an empty object
const object = {}

2. Make a property for your object that can be accessed with a dot notation.
object.property1 = 'value1'

3. Make a property for your object that can only be accessed with the bracket notation.
object['property 2'] = 'value2'

4. Get the value of a property with the dot notation
const objectProperty1 = object.property1
console.log(objectProperty1)

5. Get the value of a property with the square bracket notation
const objectProperty2 = object['property 2']
console.log(objectProperty2)

6. Set the value of a property with the dot notation
object.property1 = 'new property 1'

7. Set the value of a property with the square bracket notation
object['property 2'] = 'new property 2'

8. Make a method. Call this method
object.aMethodOriginal = function () {
	console.log('I called a method.')
}

object.aMethodOriginal() // I called a method

9. Make a method that takes in an argument. Call this method
object.aMethod = function (arg1) {
	console.log(arg1)
}

object.aMethod('hello') // hello


-------------------------------------------------------

If/else statements (control flow statement)

if (condition) {
	// Do something
} else {
	// Do some other thing
}

If the condition evaluates to true, JavaScript executes the code from the if block.
If the condition evaluates to false, JavaScript executes the code from the else block.


### If you need to check more than one condition, you can use else if, which goes between if and else.

If the first condition evaluates to false, JavaScript checks the condition in the next else if block and see whether it evaluates to true. It goes on and on until all else if blocks are exhausted.


To check whether a condition evaluates to true or false, JavaScript relies on two things:
1. Comparison operators
2. Truthy and falsey values


### 4 main types of comparison operators
1. Greater than ( > ) or greater or equals to ( >= )
2. Smaller than ( < ) or smaller or equals to ( <= )
3. Strictly equal ( === ) or equal ( == )
4. Strictly unequal ( !== ) or unequal ( != )


JavaScript is a loosely-typed language. When we declare variables, we don't care what type of value goes into the variable.

When comparing things with strictly equal ( === ) or strictly unequal ( !== ), JavaScript checks two things:
1. The type of the variable
2. The value of the variable

// a string of 24 and a number of 24 does not equate
'24' === 24 // False
'24' !== 24 // True

When comparing things with equal ( == ) or unequal ( != ) JavaScript converts (or casts) the types so they match each other.

Generally, JavaScript tries to convert all types to numbers when you use a conversion operator.

Booleans can also be converted into numbers.
true becomes 1
false becomes 0

0 == false // True
1 == true // True
2 == true // False


### Whenever you compare for equality, always use the strict versions ( === ) or ( !== )

### Comparing Objects:
When you compare objects with equality operators, you are asking JavaScript to check if the two objects have the same reference (same identity card).

// two objects never equate, because they point to different references
const zell = { isHavingFun: true }
const vincy = { isHavingFun: true }

console.log(zell === vincy) // false
console.log(zell == vincy) // false

### To check if two objects have the same property-value pairs, you need to compare every property-value pairs between the two objects.

Truthy and falsey

If you write a single variable as the condition of an if/else statement, JavaScript checks for a truthy or a falsey value.

const numApples = 135

if (numApples) {
	// Eat an apple
} else {
	// Buy an apple
}

### A falsey value is a value that evaluates to false when converted into a boolean.
Six possible falsey values in JavaScript.
1. false
2. undefined
3. Null
4. 0 (numeric zero)
5. "" (empty string)
6. NaN (not a number)

### A truthy value is a value that evaluates to true when converted into a boolean. In the case for numbers, anything that is not 0 converts to true.


### Automatic type conversions to truthy and falsey values are highly encouraged in JavaScript. They make code shorter and easier to comprehend.


For example, if you want to check if a string is empty, you can use the string in the condition straightaway.

const str = ''

if (str) {
  // Do something if string is not empty
} else {
  // Do something if string is empty
}

Exercises:

const james = 22
const valerie = 25
const kenneth = 27

James is 22 years old, Valerie is 25 years old, Kenneth is 27 years old. Answer the following questions with the above code:

1. Make an if/else statement to check if you are younger than James.
if (32 < james) {
	// I am younger
} else {
	// I am older
}

2. Make an else if statement within your if/else to check if you are older than Valerie.
if (32 < james) {
	// I am younger than James
} else if (32 > valerie) {
	// I am older than Valerie
} else {
	// I am older than James
}

3. Make another else if statement to check if you're as old as Kenneth.
if (james >= 32) {
	// I am younger than James
} else if (valerie < 32) {
	// I am older than Valerie
} else if (32 === kenneth) {
	// I am as old as Kenneth
} else {
	// I am older than James
}

When you do the above exercise, try comparing values with

> and >=
< and <=
===
!==


Answer the rest of the questions below with reference to the following code:

const someValue = 22
if (someValue) {
  // Executes if true
  console.log('True')
} else {
  // Executes if false
  console.log('False')
}

Would the if statement above execute:

If someValue is false? no
If someValue is true? yes
If someValue is null? no
If someValue is undefined? no
If someValue is 0? no
If someValue is -1? yes
If someValue is ''? no
If someValue is 'has a value!'? yes
If someValue is {}? yes
If someValue is { isHavingFun: true }? yes
If someValue is []? yes
If someValue is ['one', 'two', 'three']? yes


----------------------------------------------------------------
The NOT operator ( ! ) flips truthy and falsey values around. Truthy values become false, and falsey values become true.

console.log(!22) // false
console.log(!false) // true

The NOT operator can be used to eliminate else statements:

const str = ''

if(!str) {
  // Only do something if string is empty (NOT truthy)
}

### Double negation

!!someVariable

!! here is called a double negation. It does the following:

converts a truthy value to true
converts a falsey value to false.

Double negation is used to explicitly cast a truthy or falsey value into a boolean (true or false).

Exercise:

What values would you get for each of these expressions?

!2550284	// false
!true		// false
!NaN		// true
!{}			// false
!!'Pandas are adorable!'	// true
!!''		// false


---------------------------------------------------------------------
Null and Undefined

undefined is a value that indicates the absence of a value.
When something is not explicitly defined, it is undefined.

let a
console.log(a) // undefined

If you have a function that returns nothing, the result of the function will be undefined.

const returnsNothing = () => {}

const test = returnsNothing()
console.log(test) // undefined

null is a value that is used to indicate "nothingness". Developers need to explicitly set a value to be null.

const zell = {
  firstName: 'Zell',
  middleName: null,
  lastName: 'Liew'
}

console.log(zell.middleName) // null


null and undefined are different primitives.

null === undefined // false

--------------------------------------------------------------------
The BOM and the DOM
